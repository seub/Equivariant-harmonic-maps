******************************** PILE ********************************


change the code of the mesh constructor so I don't have to rearrange the order after for building the graph (yuck)

rewrite generatepolygon
rewrite triangulater with flips

add rotations to mobiusing
add shift (only keys ?)
add zoom keys

utiliser des arrays au lieu de vectors débiles±

construire le mesh et la fonction dans un thread?

faire le super update
pour trouver le bon lambda, observer expérimentalement comment varient les deltas.

ajouter le point highlighted quand il est sur lr bord

faire un dégradé de couleur dès le départ



******************************** IMPROVE CODE ********************************

assert vs throw
track down code duplication
move semantics http://stackoverflow.com/questions/3106110/what-are-move-semantics
hunt memory leaks, test with valgrind
foutre des auto partout


******************************** BUGS: ********************************


************************* FUTURE PLANS ***************************

0. Don't break keys off in locks.
1. Are quadratic weights dead?
2. Think about equivariance: Explain the picture of the (almost) harmonic map from a rho to its Dehn twist.
3. Improve choice of steiner points and cuts
4. Improve choice of fundamental domain (try dirichlet?)
5. Think about automating in a totally different way: Fix a weighted graph that triangulates the surface ahead of time (relations on weights?), and use the algorithm to embed it "harmonically" on the surface.
6. H3 and SL(2,C)-character variety?
7. Slices of the character variety and pictures?
8. Hopf differential? Energy?


************************* OPTIMIZATION ***************************

For the record, after going to lift graph, speed (release build) was multiplied by approximately 2.

Optimisation :
-faire un truc semblable à super_compute_radii for CP. en tout cas envsiager de revenir à une méthode de flot où on choisit le pas.
- utiliser le profiler



J'ai réussi à faire les calculs, Nicolas avait raison : le centroïde minimise la somme pondérée des cosinus hyperboliques des distances
(pas de facteur 2, pas de carré, exactement ch(distance)))
